import { fetch } from "@tauri-apps/plugin-http";

export interface TranscriptSegment {
  start: number;
  duration: number;
  text: string;
}

export interface TranscriptResult {
  language: string;
  isAutoGenerated: boolean;
  transcript: string;
  segments: TranscriptSegment[];
}

interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  kind?: string;
  name?: { simpleText: string };
}

export async function fetchTranscript(
  videoId: string
): Promise<TranscriptResult | null> {
  try {
    // Fetch the video page to get caption track info
    const pageResponse = await fetch(
      `https://www.youtube.com/watch?v=${videoId}`,
      {
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        },
      }
    );

    if (!pageResponse.ok) {
      console.error("Failed to fetch video page");
      return null;
    }

    const html = await pageResponse.text();

    // Extract caption tracks from the page
    const captionMatch = html.match(/"captionTracks":(\[.*?\])/);
    if (!captionMatch) {
      console.log("No captions found for video:", videoId);
      return null;
    }

    let captionTracks: CaptionTrack[];
    try {
      captionTracks = JSON.parse(captionMatch[1]);
    } catch {
      console.error("Failed to parse caption tracks");
      return null;
    }

    if (!captionTracks.length) {
      return null;
    }

    // Prefer manual captions over auto-generated
    const track =
      captionTracks.find(
        (t: CaptionTrack) => !t.kind || t.kind !== "asr"
      ) || captionTracks[0];

    // Fetch the transcript
    const transcriptResponse = await fetch(track.baseUrl, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      },
    });

    if (!transcriptResponse.ok) {
      console.error("Failed to fetch transcript");
      return null;
    }

    const transcriptXml = await transcriptResponse.text();
    console.log("[transcript] XML preview:", transcriptXml.substring(0, 500));

    // Parse the XML transcript
    const segments = parseTranscriptXml(transcriptXml);
    console.log("[transcript] Parsed segments count:", segments.length);
    const fullText = segments.map((s) => s.text).join(" ");

    return {
      language: track.languageCode || "en",
      isAutoGenerated: track.kind === "asr",
      transcript: fullText,
      segments,
    };
  } catch (error) {
    console.error("Failed to fetch transcript:", error);
    return null;
  }
}

function parseTranscriptXml(xml: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];

  // Try the new YouTube format first: <p t="..." d="...">content</p>
  // where t and d are in milliseconds (attributes can be in any order)
  const pTagRegex = /<p\s+([^>]*)>(.*?)<\/p>/gs;
  let match;

  while ((match = pTagRegex.exec(xml)) !== null) {
    const attrs = match[1];
    const content = match[2];

    const tMatch = attrs.match(/\bt="(\d+)"/);
    const dMatch = attrs.match(/\bd="(\d+)"/);

    if (tMatch && dMatch) {
      segments.push({
        start: parseInt(tMatch[1]) / 1000, // Convert ms to seconds
        duration: parseInt(dMatch[1]) / 1000,
        text: decodeHtmlEntities(content),
      });
    }
  }

  // If no matches, try the old format: <text start="..." dur="...">content</text>
  // where start and dur are in seconds
  if (segments.length === 0) {
    const oldFormatRegex = /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>(.*?)<\/text>/g;
    while ((match = oldFormatRegex.exec(xml)) !== null) {
      segments.push({
        start: parseFloat(match[1]),
        duration: parseFloat(match[2]),
        text: decodeHtmlEntities(match[3]),
      });
    }
  }

  return segments;
}

function decodeHtmlEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#(\d+);/g, (_match, dec) => String.fromCharCode(dec))
    .replace(/<[^>]+>/g, "") // Remove any remaining HTML tags
    .replace(/\n/g, " ")
    .trim();
}
