import { fetch } from "@tauri-apps/plugin-http";

export interface TranscriptSegment {
  start: number;
  duration: number;
  text: string;
}

export interface TranscriptResult {
  language: string;
  isAutoGenerated: boolean;
  transcript: string;
  segments: TranscriptSegment[];
}

interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  kind?: string;
  name?: { simpleText: string };
}

export async function fetchTranscript(
  videoId: string
): Promise<TranscriptResult | null> {
  try {
    // Fetch the video page to get caption track info
    const pageResponse = await fetch(
      `https://www.youtube.com/watch?v=${videoId}`,
      {
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        },
      }
    );

    if (!pageResponse.ok) {
      console.error("Failed to fetch video page");
      return null;
    }

    const html = await pageResponse.text();

    // Extract caption tracks from the page
    const captionMatch = html.match(/"captionTracks":(\[.*?\])/);
    if (!captionMatch) {
      console.log("No captions found for video:", videoId);
      return null;
    }

    let captionTracks: CaptionTrack[];
    try {
      captionTracks = JSON.parse(captionMatch[1]);
    } catch {
      console.error("Failed to parse caption tracks");
      return null;
    }

    if (!captionTracks.length) {
      return null;
    }

    // Prefer manual captions over auto-generated
    const track =
      captionTracks.find(
        (t: CaptionTrack) => !t.kind || t.kind !== "asr"
      ) || captionTracks[0];

    // Fetch the transcript
    const transcriptResponse = await fetch(track.baseUrl, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      },
    });

    if (!transcriptResponse.ok) {
      console.error("Failed to fetch transcript");
      return null;
    }

    const transcriptXml = await transcriptResponse.text();

    // Parse the XML transcript
    const segments = parseTranscriptXml(transcriptXml);
    const fullText = segments.map((s) => s.text).join(" ");

    return {
      language: track.languageCode || "en",
      isAutoGenerated: track.kind === "asr",
      transcript: fullText,
      segments,
    };
  } catch (error) {
    console.error("Failed to fetch transcript:", error);
    return null;
  }
}

function parseTranscriptXml(xml: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];
  const regex = /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>(.*?)<\/text>/g;

  let match;
  while ((match = regex.exec(xml)) !== null) {
    segments.push({
      start: parseFloat(match[1]),
      duration: parseFloat(match[2]),
      text: decodeHtmlEntities(match[3]),
    });
  }

  return segments;
}

function decodeHtmlEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#(\d+);/g, (_match, dec) => String.fromCharCode(dec))
    .replace(/<[^>]+>/g, "") // Remove any remaining HTML tags
    .replace(/\n/g, " ")
    .trim();
}
