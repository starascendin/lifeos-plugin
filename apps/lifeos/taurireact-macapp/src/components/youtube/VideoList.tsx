import { useState } from "react";
import { useQuery, useConvex, useAction } from "convex/react";
import { api, type Doc, type Id } from "@holaai/convex";
import { formatDuration } from "../../lib/services/youtube-api";
import {
  syncPlaylistVideos,
  fetchMultipleTranscripts,
  SyncProgress,
  initialProgress,
} from "../../lib/services/sync";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent } from "@/components/ui/card";
import {
  RefreshCw,
  Loader2,
  CheckCircle,
  FileText,
  Play,
  Download,
  XCircle,
  RotateCw,
} from "lucide-react";
import { fetchTranscript } from "../../lib/services/transcript";

interface VideoListProps {
  playlistId: Id<"life_youtubePlaylists">;
  youtubePlaylistId: string;
  onSelectVideo: (video: Doc<"life_youtubeVideos">) => void;
  selectedVideoId?: Id<"life_youtubeVideos">;
}

export function VideoList({
  playlistId,
  youtubePlaylistId,
  onSelectVideo,
  selectedVideoId,
}: VideoListProps) {
  const videos = useQuery(api.lifeos.youtube.getVideos, { playlistId });
  const convex = useConvex();
  const getGoogleToken = useAction(api.lifeos.youtube.getGoogleOAuthToken);

  const [selectedVideos, setSelectedVideos] = useState<Set<Id<"life_youtubeVideos">>>(new Set());
  const [refetchingVideoId, setRefetchingVideoId] = useState<Id<"life_youtubeVideos"> | null>(null);
  const [syncProgress, setSyncProgress] = useState<SyncProgress>(initialProgress);
  const [transcriptProgress, setTranscriptProgress] = useState<{
    status: "idle" | "fetching" | "complete" | "error";
    current: number;
    total: number;
    currentTitle: string;
    successful: number;
    failed: number;
    error?: string;
  }>({
    status: "idle",
    current: 0,
    total: 0,
    currentTitle: "",
    successful: 0,
    failed: 0,
  });

  const handleSyncVideos = async () => {
    try {
      const { token } = await getGoogleToken();
      if (!token) {
        console.error("Could not get Google OAuth token");
        return;
      }
      await syncPlaylistVideos(convex, token, playlistId, youtubePlaylistId, setSyncProgress);
    } catch (err) {
      console.error("Failed to get Google token:", err);
    }
  };

  const toggleVideoSelection = (videoId: Id<"life_youtubeVideos">) => {
    setSelectedVideos((prev) => {
      const next = new Set(prev);
      if (next.has(videoId)) {
        next.delete(videoId);
      } else {
        next.add(videoId);
      }
      return next;
    });
  };

  const selectAllWithoutTranscript = () => {
    if (!videos) return;
    const videosWithoutTranscript = videos.filter((v) => !v.hasTranscript);
    setSelectedVideos(new Set(videosWithoutTranscript.map((v) => v._id)));
  };

  const clearSelection = () => {
    setSelectedVideos(new Set());
  };

  const handleRefetchTranscript = async (video: Doc<"life_youtubeVideos">) => {
    setRefetchingVideoId(video._id);
    try {
      console.log("[VideoList] Refetching transcript for:", video.title);
      const result = await fetchTranscript(video.youtubeVideoId);

      if (result && result.segments.length > 0) {
        // Save transcript to Convex
        await convex.mutation(api.lifeos.youtube.upsertTranscript, {
          videoId: video._id,
          youtubeVideoId: video.youtubeVideoId,
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          transcript: result.transcript,
          segments: result.segments,
        });

        // Update video to mark hasTranscript (preserve all existing fields)
        await convex.mutation(api.lifeos.youtube.upsertVideo, {
          youtubeVideoId: video.youtubeVideoId,
          playlistId: video.playlistId!,
          title: video.title,
          description: video.description,
          channelTitle: video.channelTitle,
          duration: video.duration,
          thumbnailUrl: video.thumbnailUrl,
          publishedAt: video.publishedAt,
          hasTranscript: true,
        });

        console.log("[VideoList] Transcript saved successfully");
      } else {
        console.log("[VideoList] No transcript content found");
      }
    } catch (err) {
      console.error("[VideoList] Failed to refetch transcript:", err);
    } finally {
      setRefetchingVideoId(null);
    }
  };

  const handleFetchTranscripts = async () => {
    if (!videos || selectedVideos.size === 0) return;

    const videosToFetch = videos
      .filter((v) => selectedVideos.has(v._id) && !v.hasTranscript)
      .map((v) => ({
        videoId: v._id,
        youtubeVideoId: v.youtubeVideoId,
        playlistId: v.playlistId!,
        title: v.title,
        description: v.description,
        channelTitle: v.channelTitle,
        duration: v.duration,
        thumbnailUrl: v.thumbnailUrl,
        publishedAt: v.publishedAt,
      }));

    if (videosToFetch.length === 0) {
      setTranscriptProgress({
        status: "complete",
        current: 0,
        total: 0,
        currentTitle: "",
        successful: 0,
        failed: 0,
        error: "All selected videos already have transcripts",
      });
      return;
    }

    setTranscriptProgress({
      status: "fetching",
      current: 0,
      total: videosToFetch.length,
      currentTitle: "",
      successful: 0,
      failed: 0,
    });

    const result = await fetchMultipleTranscripts(
      convex,
      videosToFetch,
      (current, total, title) => {
        setTranscriptProgress((prev) => ({
          ...prev,
          current,
          total,
          currentTitle: title,
        }));
      }
    );

    setTranscriptProgress({
      status: "complete",
      current: videosToFetch.length,
      total: videosToFetch.length,
      currentTitle: "",
      successful: result.successful,
      failed: result.failed,
    });

    setSelectedVideos(new Set());
  };

  const isSyncing = syncProgress.status === "syncing";
  const isFetchingTranscripts = transcriptProgress.status === "fetching";

  const getTranscriptProgressPercentage = () => {
    if (transcriptProgress.total === 0) return 0;
    return Math.round((transcriptProgress.current / transcriptProgress.total) * 100);
  };

  // Loading state
  if (videos === undefined) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  // Empty state
  if (videos.length === 0) {
    return (
      <div className="space-y-4">
        <div className="text-center py-8 text-muted-foreground">
          <Play className="h-8 w-8 mx-auto mb-2 opacity-50" />
          <p className="text-sm">No videos synced for this playlist yet.</p>
          <p className="text-xs mt-1">Click below to fetch videos.</p>
        </div>
        <Button
          onClick={handleSyncVideos}
          disabled={isSyncing}
          className="w-full"
        >
          {isSyncing ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              {syncProgress.currentStep}
            </>
          ) : (
            <>
              <Download className="h-4 w-4 mr-2" />
              Fetch Videos
            </>
          )}
        </Button>
      </div>
    );
  }

  const videosWithoutTranscript = videos.filter((v) => !v.hasTranscript).length;
  const selectedWithoutTranscript = videos.filter(
    (v) => selectedVideos.has(v._id) && !v.hasTranscript
  ).length;

  return (
    <div className="flex flex-col h-full">
      {/* Action bar */}
      <div className="flex-shrink-0 mb-3 space-y-2">
        {/* Sync videos button */}
        <Button
          variant="outline"
          onClick={handleSyncVideos}
          disabled={isSyncing || isFetchingTranscripts}
          className="w-full"
        >
          {isSyncing ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              {syncProgress.currentStep}
            </>
          ) : (
            <>
              <RefreshCw className="h-4 w-4 mr-2" />
              Refresh Videos
            </>
          )}
        </Button>

        {/* Selection actions */}
        {videosWithoutTranscript > 0 && (
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={selectAllWithoutTranscript}
              disabled={isFetchingTranscripts}
              className="flex-1"
            >
              Select All ({videosWithoutTranscript})
            </Button>
            {selectedVideos.size > 0 && (
              <Button
                variant="outline"
                size="sm"
                onClick={clearSelection}
                disabled={isFetchingTranscripts}
              >
                <XCircle className="h-4 w-4 mr-1" />
                Clear
              </Button>
            )}
          </div>
        )}

        {/* Fetch transcripts button with progress */}
        {selectedVideos.size > 0 && (
          <div className="space-y-2">
            <Button
              onClick={handleFetchTranscripts}
              disabled={isFetchingTranscripts || selectedWithoutTranscript === 0}
              className="w-full"
            >
              {isFetchingTranscripts ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Fetching {transcriptProgress.current}/{transcriptProgress.total}...
                </>
              ) : (
                <>
                  <FileText className="h-4 w-4 mr-2" />
                  Fetch Transcripts ({selectedWithoutTranscript})
                </>
              )}
            </Button>
            {isFetchingTranscripts && (
              <div className="space-y-1">
                <Progress value={getTranscriptProgressPercentage()} className="h-1.5" />
                <p className="text-xs text-muted-foreground truncate">
                  {transcriptProgress.currentTitle}
                </p>
              </div>
            )}
          </div>
        )}

        {/* Completion status */}
        {transcriptProgress.status === "complete" && transcriptProgress.total > 0 && (
          <Card className="border-green-200 bg-green-50 dark:border-green-900 dark:bg-green-950">
            <CardContent className="p-2 flex items-center gap-2">
              <CheckCircle className="h-4 w-4 text-green-600" />
              <span className="text-xs text-green-700 dark:text-green-400">
                Done! {transcriptProgress.successful} fetched
                {transcriptProgress.failed > 0 && `, ${transcriptProgress.failed} failed`}
              </span>
            </CardContent>
          </Card>
        )}
        {transcriptProgress.error && !transcriptProgress.total && (
          <p className="text-xs text-center text-muted-foreground">
            {transcriptProgress.error}
          </p>
        )}
      </div>

      {/* Video list */}
      <div className="flex-1 overflow-y-auto space-y-2">
        {videos.map((video) => {
          const isSelected = selectedVideos.has(video._id);
          const isViewing = selectedVideoId === video._id;

          return (
            <Card
              key={video._id}
              className={`transition-colors cursor-pointer ${
                isViewing
                  ? "bg-primary text-primary-foreground border-primary"
                  : isSelected
                    ? "bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800"
                    : "hover:bg-accent"
              }`}
            >
              <CardContent className="p-2 flex items-start gap-3">
                {/* Checkbox for selection */}
                <div className="pt-1">
                  <Checkbox
                    checked={isSelected}
                    onCheckedChange={() => toggleVideoSelection(video._id)}
                    disabled={isFetchingTranscripts || video.hasTranscript}
                    className={video.hasTranscript ? "opacity-30" : ""}
                  />
                </div>

                {/* Video content - clickable to view */}
                <div
                  onClick={() => onSelectVideo(video)}
                  className="flex-1 flex items-start gap-3 text-left cursor-pointer"
                >
                  <div className="relative flex-shrink-0">
                    {video.thumbnailUrl ? (
                      <img
                        src={video.thumbnailUrl}
                        alt=""
                        className="w-20 h-12 object-cover rounded"
                      />
                    ) : (
                      <div className="w-20 h-12 bg-muted rounded flex items-center justify-center">
                        <Play className="h-6 w-6 text-muted-foreground" />
                      </div>
                    )}
                    {video.duration && (
                      <Badge
                        variant="secondary"
                        className="absolute bottom-0.5 right-0.5 px-1 py-0 text-[10px] bg-black/80 text-white border-0"
                      >
                        {formatDuration(video.duration)}
                      </Badge>
                    )}
                  </div>
                  <div className="flex-1 min-w-0">
                    <h3 className="font-medium text-xs line-clamp-2">{video.title}</h3>
                    <p className={`text-[10px] mt-0.5 ${isViewing ? "opacity-70" : "text-muted-foreground"}`}>
                      {video.channelTitle}
                    </p>
                    {video.hasTranscript && (
                      <Badge
                        variant="outline"
                        className={`mt-1 text-[10px] py-0 h-4 ${
                          isViewing
                            ? "border-primary-foreground/50 text-primary-foreground/70"
                            : "border-green-600 text-green-600"
                        }`}
                      >
                        <CheckCircle className="h-2.5 w-2.5 mr-0.5" />
                        Transcript
                      </Badge>
                    )}
                  </div>
                </div>

                {/* Refetch button - outside the clickable area */}
                {video.hasTranscript && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-6 w-6 p-0 flex-shrink-0"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleRefetchTranscript(video);
                    }}
                    disabled={refetchingVideoId === video._id || isFetchingTranscripts}
                    title="Refetch transcript"
                  >
                    {refetchingVideoId === video._id ? (
                      <Loader2 className="h-3 w-3 animate-spin" />
                    ) : (
                      <RotateCw className="h-3 w-3" />
                    )}
                  </Button>
                )}
              </CardContent>
            </Card>
          );
        })}
      </div>
    </div>
  );
}
