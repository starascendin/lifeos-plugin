import { defineTable } from "convex/server";
import { v } from "convex/values";
import { chatnexusTables } from "./chatnexus_schema";
import { habitsTables } from "./habits_schema";
import { llmcouncilTables } from "./llmcouncil_schema";
import { pmTables } from "./pm_schema";

/**
 * LifeOS Tables
 *
 * Tables for the LifeOS personal productivity app.
 * All table names are prefixed with `life_` or `lifeos_chatnexus` or `lifeos_pm` to avoid conflicts.
 */
export const lifeosTables = {
  // Chat Nexus tables
  ...chatnexusTables,
  // LLM Council tables
  ...llmcouncilTables,
  // Project Management tables
  ...pmTables,
  // Habit Tracker tables
  ...habitsTables,
  // ==================== YOUTUBE PLAYLISTS ====================
  life_youtubePlaylists: defineTable({
    // User who owns this playlist sync
    userId: v.id("users"),
    // YouTube playlist ID (e.g., "PLxxx...")
    youtubePlaylistId: v.string(),
    // Playlist title
    title: v.string(),
    // Playlist description
    description: v.optional(v.string()),
    // Channel that owns the playlist
    channelTitle: v.optional(v.string()),
    // Number of videos in playlist
    videoCount: v.optional(v.number()),
    // Playlist thumbnail URL
    thumbnailUrl: v.optional(v.string()),
    // Last time this playlist was synced
    lastSyncedAt: v.number(),
    // Timestamps
    createdAt: v.number(),
    // When playlist metadata was last updated (title, videoCount, etc.)
    updatedAt: v.optional(v.number()),
  })
    .index("by_user", ["userId"])
    .index("by_youtube_id", ["youtubePlaylistId"])
    .index("by_user_youtube_id", ["userId", "youtubePlaylistId"]),

  // ==================== YOUTUBE VIDEOS ====================
  life_youtubeVideos: defineTable({
    // User who owns this video sync
    userId: v.id("users"),
    // Reference to playlist (optional - video might be standalone)
    playlistId: v.optional(v.id("life_youtubePlaylists")),
    // YouTube video ID (e.g., "dQw4w9WgXcQ")
    youtubeVideoId: v.string(),
    // Video title
    title: v.string(),
    // Video description
    description: v.optional(v.string()),
    // Channel name
    channelTitle: v.optional(v.string()),
    // Duration in seconds
    duration: v.optional(v.number()),
    // Thumbnail URL
    thumbnailUrl: v.optional(v.string()),
    // When the video was published on YouTube
    publishedAt: v.optional(v.string()),
    // Whether we have a transcript for this video
    hasTranscript: v.boolean(),
    // Timestamps
    createdAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_youtube_id", ["youtubeVideoId"])
    .index("by_user_youtube_id", ["userId", "youtubeVideoId"])
    .index("by_playlist", ["playlistId"]),

  // ==================== YOUTUBE TRANSCRIPTS ====================
  life_youtubeTranscripts: defineTable({
    // User who owns this transcript
    userId: v.id("users"),
    // Reference to the video
    videoId: v.id("life_youtubeVideos"),
    // YouTube video ID (denormalized for easier queries)
    youtubeVideoId: v.string(),
    // Language code (e.g., "en", "es", "zh")
    language: v.string(),
    // Whether this is auto-generated captions
    isAutoGenerated: v.boolean(),
    // Full transcript text (concatenated)
    transcript: v.string(),
    // Timed segments for precise lookups
    segments: v.optional(
      v.array(
        v.object({
          start: v.number(), // Start time in seconds
          duration: v.number(), // Duration in seconds
          text: v.string(), // Segment text
        })
      )
    ),
    // Timestamps
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_video", ["videoId"])
    .index("by_youtube_id", ["youtubeVideoId"])
    .index("by_user_youtube_id", ["userId", "youtubeVideoId"]),

  // ==================== SCREEN TIME SESSIONS ====================
  life_screentimeSessions: defineTable({
    // User who owns this session
    userId: v.id("users"),
    // Unique identifier for this session (bundleId_startTime for deduplication)
    sessionKey: v.string(),
    // App bundle identifier (e.g., "com.apple.Safari")
    bundleId: v.string(),
    // Human-readable app name
    appName: v.optional(v.string()),
    // App category (productivity, social, entertainment, etc.)
    category: v.optional(v.string()),
    // Session timestamps (Unix epoch milliseconds)
    startTime: v.number(),
    endTime: v.number(),
    // Duration in seconds
    durationSeconds: v.number(),
    // Timezone offset in seconds from UTC
    timezoneOffset: v.optional(v.number()),
    // Device identifier
    deviceId: v.optional(v.string()),
    // Whether this is web usage (Safari/Chrome)
    isWebUsage: v.boolean(),
    // Domain for web usage sessions
    domain: v.optional(v.string()),
    // Timestamps
    createdAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_date", ["userId", "startTime"])
    .index("by_session_key", ["userId", "sessionKey"])
    .index("by_user_bundle", ["userId", "bundleId"]),

  // ==================== SCREEN TIME DAILY SUMMARIES ====================
  life_screentimeDailySummaries: defineTable({
    // User who owns this summary
    userId: v.id("users"),
    // Date string in YYYY-MM-DD format (in user's local timezone)
    date: v.string(),
    // Total screen time for the day in seconds
    totalSeconds: v.number(),
    // Per-app breakdown
    appUsage: v.array(
      v.object({
        bundleId: v.string(),
        appName: v.optional(v.string()),
        category: v.optional(v.string()),
        seconds: v.number(),
        sessionCount: v.number(),
      })
    ),
    // Per-category breakdown
    categoryUsage: v.array(
      v.object({
        category: v.string(),
        seconds: v.number(),
      })
    ),
    // Device identifier
    deviceId: v.optional(v.string()),
    // Timestamps
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_date", ["userId", "date"]),

  // ==================== SCREEN TIME SYNC STATUS ====================
  life_screentimeSyncStatus: defineTable({
    // User who owns this sync status
    userId: v.id("users"),
    // Last successful sync timestamp (Unix epoch ms)
    lastSyncAt: v.optional(v.number()),
    // Last session timestamp synced (to enable incremental sync)
    lastSessionTime: v.optional(v.number()),
    // Device identifier
    deviceId: v.optional(v.string()),
    // Whether auto-sync is enabled
    autoSyncEnabled: v.boolean(),
    // Auto-sync interval in minutes
    autoSyncIntervalMinutes: v.optional(v.number()),
    // Timestamps
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"]),

  // ==================== VOICE MEMOS ====================
  life_voiceMemos: defineTable({
    // User who owns this memo
    userId: v.id("users"),
    // Client-generated UUID (for linking local to cloud)
    localId: v.string(),
    // User-editable name
    name: v.string(),
    // Convex file storage ID for the audio file (optional for transcript-only syncs)
    storageId: v.optional(v.id("_storage")),
    // Duration in milliseconds
    duration: v.number(),
    // Transcription status
    transcriptionStatus: v.union(
      v.literal("pending"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    ),
    // Error message if transcription failed
    transcriptionError: v.optional(v.string()),
    // Full transcription text
    transcript: v.optional(v.string()),
    // Timed segments (matching YouTube transcript pattern)
    segments: v.optional(
      v.array(
        v.object({
          start: v.number(), // Start time in seconds
          duration: v.number(), // Duration in seconds
          text: v.string(), // Segment text
        })
      )
    ),
    // Language detected/specified
    language: v.optional(v.string()),
    // Original client timestamps
    clientCreatedAt: v.number(),
    clientUpdatedAt: v.number(),
    // Server timestamps
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_localId", ["userId", "localId"])
    .index("by_user_created", ["userId", "clientCreatedAt"]),
};
