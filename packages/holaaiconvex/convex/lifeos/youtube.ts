import { v } from "convex/values";
import { action, mutation, query } from "../_generated/server";
import { requireUser } from "../_lib/auth";
import { createClerkClient } from "@clerk/backend";

// ==================== MUTATIONS ====================

/**
 * Upsert a YouTube playlist
 * Creates or updates a playlist for the authenticated user
 */
export const upsertPlaylist = mutation({
  args: {
    youtubePlaylistId: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    channelTitle: v.optional(v.string()),
    videoCount: v.optional(v.number()),
    thumbnailUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);
    const now = Date.now();

    // Check if playlist already exists for this user
    const existing = await ctx.db
      .query("life_youtubePlaylists")
      .withIndex("by_user_youtube_id", (q) =>
        q.eq("userId", user._id).eq("youtubePlaylistId", args.youtubePlaylistId)
      )
      .unique();

    if (existing) {
      // Update existing playlist
      await ctx.db.patch(existing._id, {
        title: args.title,
        description: args.description,
        channelTitle: args.channelTitle,
        videoCount: args.videoCount,
        thumbnailUrl: args.thumbnailUrl,
        lastSyncedAt: now,
        updatedAt: now,
      });
      return existing._id;
    }

    // Create new playlist
    return await ctx.db.insert("life_youtubePlaylists", {
      userId: user._id,
      youtubePlaylistId: args.youtubePlaylistId,
      title: args.title,
      description: args.description,
      channelTitle: args.channelTitle,
      videoCount: args.videoCount,
      thumbnailUrl: args.thumbnailUrl,
      lastSyncedAt: now,
      createdAt: now,
      updatedAt: now,
    });
  },
});

/**
 * Upsert a YouTube video
 * Creates or updates a video for the authenticated user
 */
export const upsertVideo = mutation({
  args: {
    playlistId: v.optional(v.id("life_youtubePlaylists")),
    youtubeVideoId: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    channelTitle: v.optional(v.string()),
    duration: v.optional(v.number()),
    thumbnailUrl: v.optional(v.string()),
    publishedAt: v.optional(v.string()),
    hasTranscript: v.boolean(),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);
    const now = Date.now();

    // Check if video already exists for this user
    const existing = await ctx.db
      .query("life_youtubeVideos")
      .withIndex("by_user_youtube_id", (q) =>
        q.eq("userId", user._id).eq("youtubeVideoId", args.youtubeVideoId)
      )
      .unique();

    if (existing) {
      // Update existing video
      await ctx.db.patch(existing._id, {
        playlistId: args.playlistId,
        title: args.title,
        description: args.description,
        channelTitle: args.channelTitle,
        duration: args.duration,
        thumbnailUrl: args.thumbnailUrl,
        publishedAt: args.publishedAt,
        hasTranscript: args.hasTranscript,
      });
      return existing._id;
    }

    // Create new video
    return await ctx.db.insert("life_youtubeVideos", {
      userId: user._id,
      playlistId: args.playlistId,
      youtubeVideoId: args.youtubeVideoId,
      title: args.title,
      description: args.description,
      channelTitle: args.channelTitle,
      duration: args.duration,
      thumbnailUrl: args.thumbnailUrl,
      publishedAt: args.publishedAt,
      hasTranscript: args.hasTranscript,
      createdAt: now,
    });
  },
});

/**
 * Upsert a YouTube transcript
 * Creates or updates a transcript for the authenticated user
 */
export const upsertTranscript = mutation({
  args: {
    videoId: v.id("life_youtubeVideos"),
    youtubeVideoId: v.string(),
    language: v.string(),
    isAutoGenerated: v.boolean(),
    transcript: v.string(),
    segments: v.optional(
      v.array(
        v.object({
          start: v.number(),
          duration: v.number(),
          text: v.string(),
        })
      )
    ),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);
    const now = Date.now();

    // Check if transcript already exists for this user and video
    const existing = await ctx.db
      .query("life_youtubeTranscripts")
      .withIndex("by_user_youtube_id", (q) =>
        q.eq("userId", user._id).eq("youtubeVideoId", args.youtubeVideoId)
      )
      .unique();

    if (existing) {
      // Update existing transcript
      await ctx.db.patch(existing._id, {
        videoId: args.videoId,
        language: args.language,
        isAutoGenerated: args.isAutoGenerated,
        transcript: args.transcript,
        segments: args.segments,
        updatedAt: now,
      });
      return existing._id;
    }

    // Create new transcript
    return await ctx.db.insert("life_youtubeTranscripts", {
      userId: user._id,
      videoId: args.videoId,
      youtubeVideoId: args.youtubeVideoId,
      language: args.language,
      isAutoGenerated: args.isAutoGenerated,
      transcript: args.transcript,
      segments: args.segments,
      createdAt: now,
      updatedAt: now,
    });
  },
});

/**
 * Delete a playlist and all its videos/transcripts
 */
export const deletePlaylist = mutation({
  args: {
    playlistId: v.id("life_youtubePlaylists"),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);

    // Verify ownership
    const playlist = await ctx.db.get(args.playlistId);
    if (!playlist || playlist.userId !== user._id) {
      throw new Error("Playlist not found or access denied");
    }

    // Get all videos in this playlist
    const videos = await ctx.db
      .query("life_youtubeVideos")
      .withIndex("by_playlist", (q) => q.eq("playlistId", args.playlistId))
      .collect();

    // Delete transcripts for each video
    for (const video of videos) {
      const transcripts = await ctx.db
        .query("life_youtubeTranscripts")
        .withIndex("by_video", (q) => q.eq("videoId", video._id))
        .collect();

      for (const transcript of transcripts) {
        await ctx.db.delete(transcript._id);
      }

      await ctx.db.delete(video._id);
    }

    // Delete the playlist
    await ctx.db.delete(args.playlistId);
  },
});

// ==================== QUERIES ====================

/**
 * Get all playlists for the authenticated user
 */
export const getPlaylists = query({
  args: {},
  handler: async (ctx) => {
    const user = await requireUser(ctx);

    return await ctx.db
      .query("life_youtubePlaylists")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .collect();
  },
});

/**
 * Get all videos for a playlist
 */
export const getVideos = query({
  args: {
    playlistId: v.optional(v.id("life_youtubePlaylists")),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);

    if (args.playlistId) {
      // Get videos for specific playlist
      return await ctx.db
        .query("life_youtubeVideos")
        .withIndex("by_playlist", (q) => q.eq("playlistId", args.playlistId))
        .collect();
    }

    // Get all videos for user
    return await ctx.db
      .query("life_youtubeVideos")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .collect();
  },
});

/**
 * Get transcript for a video
 */
export const getTranscript = query({
  args: {
    videoId: v.id("life_youtubeVideos"),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);

    const transcript = await ctx.db
      .query("life_youtubeTranscripts")
      .withIndex("by_video", (q) => q.eq("videoId", args.videoId))
      .unique();

    if (transcript && transcript.userId !== user._id) {
      throw new Error("Access denied");
    }

    return transcript;
  },
});

/**
 * Get transcript by YouTube video ID
 */
export const getTranscriptByYoutubeId = query({
  args: {
    youtubeVideoId: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);

    return await ctx.db
      .query("life_youtubeTranscripts")
      .withIndex("by_user_youtube_id", (q) =>
        q.eq("userId", user._id).eq("youtubeVideoId", args.youtubeVideoId)
      )
      .unique();
  },
});

/**
 * Get video by YouTube video ID
 */
export const getVideoByYoutubeId = query({
  args: {
    youtubeVideoId: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);

    return await ctx.db
      .query("life_youtubeVideos")
      .withIndex("by_user_youtube_id", (q) =>
        q.eq("userId", user._id).eq("youtubeVideoId", args.youtubeVideoId)
      )
      .unique();
  },
});

/**
 * Search transcripts by text
 */
export const searchTranscripts = query({
  args: {
    searchText: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const user = await requireUser(ctx);
    const limit = args.limit ?? 20;

    // Get all transcripts for user (basic search - for full-text search consider using a search index)
    const transcripts = await ctx.db
      .query("life_youtubeTranscripts")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .collect();

    // Filter by search text (case-insensitive)
    const searchLower = args.searchText.toLowerCase();
    const matches = transcripts.filter((t) =>
      t.transcript.toLowerCase().includes(searchLower)
    );

    return matches.slice(0, limit);
  },
});

// ==================== ACTIONS ====================

/**
 * Get Google OAuth access token for YouTube API
 * Uses Clerk backend SDK to retrieve the token
 */
export const getGoogleOAuthToken = action({
  args: {},
  handler: async (ctx): Promise<{ token: string }> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Extract Clerk user ID from the subject claim
    const clerkUserId = identity.subject;

    const secretKey = process.env.CLERK_SECRET_KEY;
    if (!secretKey) {
      throw new Error("CLERK_SECRET_KEY not configured");
    }

    const clerk = createClerkClient({ secretKey });

    const tokens = await clerk.users.getUserOauthAccessToken(
      clerkUserId,
      "oauth_google"
    );

    if (!tokens.data || tokens.data.length === 0) {
      throw new Error("No Google OAuth token found. Please sign out and sign in again with Google.");
    }

    return { token: tokens.data[0].token };
  },
});
